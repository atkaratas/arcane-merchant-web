<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcane Void Portal Experiment</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            /* Deep void background */
            background: radial-gradient(circle at center, #0a0f1e 0%, #000000 100%);
        }
        
        #portalCanvas {
            display: block;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>

    <canvas id="portalCanvas"></canvas>

    <script>
        const canvas = document.getElementById('portalCanvas');
        const ctx = canvas.getContext('2d');

        let width, height, centerX, centerY;
        let time = 0;

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            centerX = width / 2;
            centerY = height / 2;
        }

        window.addEventListener('resize', resize);
        resize();

        // Portal Configuration
        const config = {
            radius: 200,
            ringThickness: 20,
            colors: {
                core: '#ffffff',
                inner: '#00ffff', // Cyan
                mid: '#0066ff',   // Blue
                outer: '#9900ff'  // Purple
            }
        };

        function drawPortal() {
            ctx.clearRect(0, 0, width, height);
            
            // Adjust radius based on screen size (responsive)
            const baseRadius = Math.min(width, height) * 0.15;
            
            // 1. Vortex Swirls (Inner)
            // Create multiple rotating arcs to simulate depth
            const swirlCount = 8;
            for (let i = 0; i < swirlCount; i++) {
                ctx.save();
                ctx.translate(centerX, centerY);
                
                // Variable speed per layer for parallax effect
                const speed = 0.02 * (i + 1); 
                const rotation = time * speed + (i * (Math.PI * 2 / swirlCount));
                
                ctx.rotate(rotation);
                
                // Scale pulsation
                const scale = 1 + Math.sin(time * 0.05 + i) * 0.05;
                ctx.scale(scale, scale);

                const grad = ctx.createLinearGradient(-baseRadius, -baseRadius, baseRadius, baseRadius);
                grad.addColorStop(0, 'rgba(0, 255, 255, 0)');
                grad.addColorStop(0.5, `rgba(0, 200, 255, ${0.2 - (i * 0.02)})`);
                grad.addColorStop(1, 'rgba(100, 0, 255, 0)');

                ctx.beginPath();
                // Draw tapered arcs
                ctx.arc(0, 0, baseRadius * (0.8 + i * 0.1), 0, Math.PI * 1.5);
                ctx.strokeStyle = grad;
                ctx.lineWidth = baseRadius * 0.1;
                ctx.lineCap = 'round';
                ctx.stroke();
                
                ctx.restore();
            }

            // 2. The Main Ring (Fake 3D Bevel)
            ctx.save();
            ctx.translate(centerX, centerY);
            
            // Outer Glow
            const outerGlow = ctx.createRadialGradient(0, 0, baseRadius, 0, 0, baseRadius * 1.5);
            outerGlow.addColorStop(0, 'rgba(0, 100, 255, 0.5)');
            outerGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = outerGlow;
            ctx.beginPath();
            ctx.arc(0, 0, baseRadius * 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Ring Body
            ctx.beginPath();
            ctx.arc(0, 0, baseRadius, 0, Math.PI * 2);
            ctx.lineWidth = baseRadius * 0.15;
            
            // Bevel Gradient (Simulating Light from Top-Left)
            const ringGrad = ctx.createLinearGradient(-baseRadius, -baseRadius, baseRadius, baseRadius);
            ringGrad.addColorStop(0, '#44aaff'); // Light highlight
            ringGrad.addColorStop(0.5, '#0044aa'); // Midtone
            ringGrad.addColorStop(1, '#001133'); // Shadow
            
            ctx.strokeStyle = ringGrad;
            ctx.stroke();
            
            // Inner Edge Highlight (Rim Light)
            ctx.beginPath();
            ctx.arc(0, 0, baseRadius * 0.92, 0, Math.PI * 2);
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.stroke();

            ctx.restore();

            // 3. Core Pulse
            ctx.save();
            ctx.translate(centerX, centerY);
            const corePulse = Math.sin(time * 0.1) * 0.1 + 0.9;
            ctx.scale(corePulse, corePulse);
            
            const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, baseRadius * 0.5);
            coreGrad.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            coreGrad.addColorStop(0.3, 'rgba(0, 255, 255, 0.6)');
            coreGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = coreGrad;
            ctx.beginPath();
            ctx.arc(0, 0, baseRadius * 0.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // 4. Ground Shadow (Fake Perspective)
            ctx.save();
            ctx.translate(centerX, centerY + baseRadius * 1.8); // Position below
            ctx.scale(1, 0.2); // Flatten to ellipse
            
            const shadowGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, baseRadius);
            shadowGrad.addColorStop(0, 'rgba(0, 0, 0, 0.8)');
            shadowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = shadowGrad;
            ctx.beginPath();
            ctx.arc(0, 0, baseRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Animation Loop
            time += 1;
            requestAnimationFrame(drawPortal);
        }

        drawPortal();
    </script>
</body>
</html>